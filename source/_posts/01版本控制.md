---
title: 01版本控制
date: 2018-05-16 06:59:37
tags:
- git      
- 版本控制  
category: git
---
# 1.git能控制的文件类型  
----
所有的版本控制系统，其实只能跟踪 *`文本文件`* 的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。
版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。

而图片、视频这些 *二进制文件* ，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是 *`只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道`* 。

不幸的是，*Microsoft的Word格式是二进制格式* ，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。

因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 

*使用Windows的童鞋要特别注意* ：

千万不要使用Windows自带的 *记事本* 编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，*他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题* ，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可.  
# 2.使用git操作过程  
----
## 初始化一个Git仓库，使用git init命令。
## 添加文件到Git仓库，分两步：  
1. 第一步，使用命令git add <file>，注意，可反复多次使用，添加多个文件；  
2. 第二步，使用命令git commit -m“xxx”，完成。  
## 编码提交过程：  
1. 要随时掌握工作区的状态，使用git status命令。  
2. 如果git status告诉你有文件被修改过，用git diff可以查看修改内容.  
3. 一旦文件使用了git add命令，在使用git diff命令则不能查看diff。所以要在add之前先查看下diff，确认没有问题之后，才使用git add命令。  
4. 每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为 *commit* 。  
## 版本回退：  
1. 查看历史提交记录：git  log。  
（1）命令执行结果：  
![](/images/git/git-log.png)  
（2）不显示复杂的信息，则加上参数即可：git  log   --pretty=online  
![](/images/git/git-log-pretty.png)  
2. 每次提交的commit id都是一个SHA1计算出来的一个非常大的数字，用十六进制表示。  
3. 用 *HEAD* 表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是 *HEAD^* ，上上一个版本就是 *HEAD^^* ，当然往上100个版本写100个^比较容易数不过来，所以写成  *HEAD~100* 。  
![](/images/git/git-head.png)  
4. 回退到上一个版本“add_begin_read”，就可以使用git reset命令：  
 git reset --hard HEAD^  
 切记：如果回退到最早的版本，但是又想回退到最新的版本，则需要记录下并能找到最新版本的commit id。  
  如果要回退到最新的版本，则要找到最新版本的commit id，使用命令：  
   git reset --hard   *3628164（commit id只写前几位就行了，前提是要能被识别出来）*   
   此时，中间提交的版本也会自动找回来，git  log会显示所有的提交记录.  
5. git的回退速度很快，是因为回退机制，有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL，如下：  
![](/images/git/git-back.png)  
6. 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。  
7. 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？  
Git提供了一个命令git reflog用来记录你的每一次命令：  
执行结果如图，左边一列是每次的commit id。  
![](/images/git/git-reflog.png)  
### 现在总结一下：  
1. HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。  
2. 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。  
3. 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。  
# 3.工作区和暂存区  
----
## 工作区  
就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区。
## 版本库  
工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。  
Git的版本库里存了很多东西，其中最重要的就是称为 *stage（或者叫index）的暂存区* ，还有Git为我们自动创建的第一个分支 *master* ，以及指向master的一个指针叫 *HEAD* 。  
![](/images/git/git-stage.png)  
前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：  
1. 第一步是用git add把文件添加进去，实际上就是把文件修改添加到 *暂存区* ;  
2. 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。  

因为我们创建Git版本库时，Git自动为我们创建了 *唯一一个master分支* ，所以，现在，git commit就是往master分支上提交更改。  
你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。  
1. git diff    #是工作区(work dict)和暂存区(stage)的比较，只要用于判断是否要add此次修改。  
2. git diff --cached    #是暂存区(stage)和分支(master)的比较，主要用于判断是否要commit此次修改。
## 举例如下的一个过程：  
![](/images/git/git-stage-eg.png)  
# 4.撤销修改  
----
## 背景1  
当修改了一个文件，但是发现不想要这次修改时。
## 解决方法  
1. 可以在修改回去，然后重新add并且commit，但是如果修改的比较多，记不住时怎么办？ 
2. Git会告诉你，git checkout -- file可以丢弃工作区的修改，例如：  
git checkout -- readme.txt  
操作：把readme.txt文件在工作区的修改全部撤销，这里有两种情况：
（1）是readme.txt自修改后还没有被放到暂存区(add)，现在，撤销修改就回到和版本库一模一样的状态（上次commit之后的状态）；  
（2）一种是readme.txt已经添加到暂存区后(add)，又作了修改，现在，撤销修改就回到添加到暂存区后的状态(上次add之后的状态)。  
总之，就是让这个文件回到最近一次git commit或git add时的状态。
## 背景2  
当修改了文件内容，且已经添加到暂存区（git add），没有commit，但是此时不想要这次修改。
## 解决方案  
1. 用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：  
此时相当于此次修改没有git add，还在工作区中，git  status仍然可以看到有文件修改的状态。
2. git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。
## 背景3  
修改已经commit到了分支上。
## 解决方案  
使用git  reset   --hard  xxx，回退到上一个版本，前提是代码没有push到代码库。  
### 总结一下  
场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。

场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。

场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。  
![](/images/git/git-cancle.png) 
# 5.删除文件  
----
1. 从版本库中删除该文件，那就用命令git rm删掉，并且git commit.这个过程相当于把工作区的文件删掉了（rm  file），并且提交到暂存区中（git add rm），只要commit就提交到分支了。
2. 如果误删了文件，也没有关系，使用 *git checkout  – file* ，其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”，但是工作区的修改丢失。
3. git rm --cached test.txt 会在文件系统中保留test.txt，但版本库中的会被删除。

4. 如果在当前工作区内test.txt的修改未提交 git rm test.txt 不会删除文件而会报错；rm test.txt命令删掉的是工作区的文件。




  





