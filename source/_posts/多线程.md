---
title: 多线程
date: 2018-05-21 15:57:52
tags:
- 多线程
category: python
---
# 几个概念：  
1. join（）的作用是，在子线程完成运行之前，这个子线程的父线程将一直被阻塞。  
2. setDaemon(True)将线程声明为守护线程，必须在start() 方法调用之前设置，如果不设置为守护线程程序会被无限挂起。子线程启动后，父线程也继续执行下去，当父线程执行完最后一条语句print "all over %s" %ctime()后，没有等待子线程，直接就退出了，同时子线程也一同结束。  

# 多线程通信
1. 实现方式  
Python实现多进程间通信的方式有很多种，例如队列，管道等。  
但是这些方式只适用于多个进程都是源于同一个父进程的情况。  
如果多个进程不是源于同一个父进程，只能用共享内存，信号量等方式，但是这些方式对于复杂的数据结构，例如Queue，dict，list等，使用起来比较麻烦，不够灵活。  
Manager是一种较为高级的多进程通信方式，它能支持Python支持的的任何数据结构。  
它的原理是：先启动一个ManagerServer进程，这个进程是阻塞的，它监听一个socket，然后其他进程（ManagerClient）通过socket来连接到ManagerServer，实现通信。  
2. linux系统配置  
使用python multithreading.Pool 做多线程，遭遇bug3770，如何解？  
>Python版本：2.7.3  
系统版本：centos release 4.3  
出错语句：pool = Pool(4)  
错误信息：ImportError: This platform lacks a functioning sem_open implementation, therefore, the required synchronization primitives needed will not function, see issue 3770  

原因：没有挂载/dev/shm;python安装时需要写入东西，才能开启sem_open  
解决办法：（需要root权限；以下命令root账号执行）
>修改/etc/fstab 增加：tmpfs /dev/shm tmpfs defaults 0 0  
mount /dev/shm  
chmod 777 /dev/shm  
重装python （必须重装，没办法，安装时检查该设备是否存在，存在则可以使用sem_open)  

3. *`/dev/shm是什么？`*   
/dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。  
因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。  
/dev/shm/需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df -h命令可以看到。但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有 100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的，否则谁还敢往里头存文件呢？  
默认系统就会加载/dev/shm ，它就是所谓的tmpfs，有人说跟ramdisk（虚拟磁盘），但不一样。象虚拟磁盘一样，tmpfs 可以使用您的 RAM，但它也可以使用您的交换分区来存储。而且传统的虚拟磁盘是个块设备，并需要一个 mkfs 之类的命令才能真正地使用它，tmpfs 是一个文件系统，而不是块设备；您只是安装它，它就可以使用了。tmpfs有以下优势：
+ 动态文件系统的大小。
+ tmpfs 的另一个主要的好处是它闪电般的速度。因为典型的 tmpfs 文件系统会完全驻留在 RAM 中，读写几乎可以是瞬间的。
+ tmpfs 数据在重新启动之后不会保留，因为虚拟内存本质上就是易失的。所以有必要做一些脚本做诸如加载，绑定的操作。

4. 修改/dev/shm大小  
默认的最大一半内存大小在某些场合可能不够用，并且默认的inode数量很低一般都要调高些，这时可以用mount命令来管理它。  
>#mount -o size=1500M -o nr_inodes=1000000 -o noatime,nodiratime -o remount /dev/shm

在2G的机器上，将最大容量调到1.5G，并且inode数量调到1000000，这意味着大致可存入最多一百万个小文件。  
如果需要永久修改/dev/shm的值，需要修改/etc/fstab  
>tmpfs /dev/shm tmpfs defaults,size=1.5G 0 0  
#mount -o remount /dev/shm

5. C-S模式举例  
+ 继承于多线程模块：
>class QueueManager(BaseManager):  
""" inherite multiprocessing.basemanager for use c-s mode  
"""
&ensp;&ensp;pass
+ 创建server
>#QueueManager: server  
QueueManager.register('get_line_queue', callable=lambda:lineQueue)   
QueueManager.register('get_buf', callable=lambda:flowBuf)  
m = QueueManager(address=('', 50002), authkey='ass')  
logging.info(" main process start listen ...")  
s = m.get_server()  
s.serve_forever()
+ 创建client
>def stat(name):  
"""  
:desc: handle line data and push into flowBuf  
:args: name  
:return: none
"""  
QueueManager.register('get_line_queue')  
QueueManager.register('get_buf')  
m = QueueManager(address=('127.0.0.1', 50002), authkey='ass')  
m.connect()  
l_queue = m.get_line_queue()  
buf = m.get_buf()  
xxxx 
+ 数据流统计实例  
>典型的生产者-消费着模式  
之前，为了在Python中实现生产者-消费者模式，往往就会选择一个额外的队列系统，比如rabbitMQ之类。  
此外，你有可能还要设计一套任务对象的序列化方式以便塞入队列。如果没有队列的支持，那不排除有些同学不得不从socket服务器做起，直接跟TCP/IP打起交道来。  
其实multiprocessing.managers中有个BaseManager就为开发者提供了这样一个快速接口。  
我们假定的 *`场景是1个生产者（producer.py）+8个消费者(worker.py)的系统，还有一个中央节点负责协调（server.py）`*。  
logs=====》 process（接收输入的日志，每1w条作为一个单位，存储到lineQueue中）=====》 lineQueue（长度为200）  
&ensp;&ensp;&ensp;     =====》 multiprocessing.Pool（线程池：共8个stat进程。）  
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;stat进程：将linQueue中的log进行处理：提取需要的字段信息，排列组合存储到buffer中。使用QueueManager：client，获取lineQueue。  
&ensp;&ensp;&ensp;&ensp;=====》 dump（将存储在buffer中的数据写入到db中）  
&ensp;&ensp;&ensp;&ensp;=====》 main进程（主线程：启动上面的各个线程，以及注册QueueManager: server，注册lineQueue、flowBuf）






