---
title: 03分支管理
date: 2018-05-16 14:48:51
tags:
- git      
- 分支管理 
category: git
---
# 1.创建与合并分支
----
## 主分支master

&ensp;&ensp;每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即 *master* 分支。  
&ensp;&ensp;HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。  
&ensp;&ensp;一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：  
![](/images/git/git-head-master.png)  
## 分支
&ensp;&ensp;当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：  
![](/images/git/git-head-dev.png)  
从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：  
![](/images/git/git-head-dev-1.png)  
假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：  
![](/images/git/git-head-dev-2.png)  
## 分支开发操作
查看分支：git branch  
创建分支：git branch <name>  
切换分支：git checkout <name>  
创建+切换分支：git checkout -b <name>  
合并某分支到当前分支：git merge <name>  
删除分支：git branch -d <name>  
# 2.解决冲突
-----
## 背景
分支开发时修改了一个文件，git add并且commit，切换到master上，也修改了这个文件，也git add且commit，此时：  
![](/images/git/git-conflict.png)  
最后进行git merge时，提示有冲突，此时是不能进行切换分支的。  
![](/images/git/git-conflict-1.png)  
## 解决
1. 查看该文件内容时，发现：  
![](/images/git/git-conflict-2.png)  
2. Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，我们修改如下后保存，git  add且commit  
![](/images/git/git-conflict-3.png)  
3. 使用命令可以看到分支合并情况：  
git log --graph --pretty=oneline --abbrev-commit  
结果为：  
![](/images/git/git-conflict-4.png)  
疑问：为什么master上commit之后，就算分支和master合并了呢？并且分支上的文件内容没有发生变化。
  
# 3.分支管理
----
当master合并分支时，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息，从log上看到分支commit和master合并commit合并为一次：  
![](/images/git/git-03-01.png)  
如果merge时强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息，从log中能看出时分为两次commit：  
![](/images/git/git-03-02.png)  
所以，合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并：  
git merge --no-ff -m "merge dev with no-ff" 分支名称  
# 4.分支开发策略
----
在实际开发中，我们应该按照几个基本原则进行分支管理：  
首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；  
那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；  
你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。  
所以，团队合作的分支看起来就像这样：  
![](/images/git/git-03-03.png)  
一般有如下分支管理模型：  
![](/images/git/git-03-04.png)  
# 5.bug分支stash
----
## 背景
当前开发工作还没有结束，即代码没有提交，但是需要先修复一个bug，怎么进行分支管理呢？  
已知情况：如果当前分支没有提交，也就是没有git  add且commit，是不能切换到另一个分支的。  
## 解决
1. 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作.  
![](/images/git/git-03-05.png)  
这个命令在git  add之前、之后执行都可以。  
2. 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。
3. 然后确定在哪个分支上进行bug的修复，假定需要在master分支上修复，就从master创建临时分支：  
&ensp;&ensp;先切换到master分支：git  checkout  master  
&ensp;&ensp;然后创建分支：git  checkout -b  bug_issue_101  
&ensp;&ensp; *切记：在master上创建分支，就要先切换到master，这样创建出来的分支才是和master内容一致的；同理，要merge分支之前，也要先切换到master上，这样才是将分支代码合并到master上* 。   
4. bug分支merge到master后，在切换会dev分支进行开发，可以使用命令：git stash list，查看被储藏起来的工作现场。  
恢复工作现场：  
&ensp;&ensp;git  stash  pop：同时删除stash内容  
&ensp;&ensp;git  stash  apply；不会删除stash内容，stash list仍然可以看到内容，需要使用git stash drop来删除。  
&ensp;&ensp;stash list是一个栈，可以看到有多个stash：  
![](/images/git/git-03-06.png)  
可以恢复指定的stash：git stash apply stash@{0}